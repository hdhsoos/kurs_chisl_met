def Bernulli(Y_p, sec=True):
    # Y previous
    # Y_p = [y0, y1, y2, y3]
    if sec:  # если считаем наибольший корень
        y_i = -9 * Y_p[3] + 14 * Y_p[2] + 216 * Y_p[1] + 320 * Y_p[0]
    else:  # если считаем наименьший корень
        y_i = -(216 * Y_p[3] + 14 * Y_p[2] - 9 * Y_p[1] - Y_p[0]) / 320
    return [Y_p[1:] + [y_i], y_i, y_i / Y_p[3]]  # [Y_p_new, y_i, y_i/y_i-1]
    # мы вернули новый список из четырех y, новое y, примерное значение макс корня


def kvadrirov(a):
    # a = [a_0, a_1, a_2, a_3, a_4]
    A_0 = a[0] ** 2
    A_1 = a[1] ** 2 - 2 * a[0] * a[2]
    A_2 = a[2] ** 2 - 2 * a[1] * a[3] + 2 * a[0] * a[4]
    A_3 = a[3] ** 2 - 2 * a[2] * a[4]
    A_4 = a[4] ** 2
    return [A_0, A_1, A_2, A_3, A_4]


def to_scientific_notation(num, usl=False):
    # перевод в формат 4.993 * 10^3
    if usl:
        res = str(num)
        res = res[0] + '.' + res[1:]
        res = float(res)
        return round(num, 7)
    else:
        snum = str(num)
        res = snum[:4]
        res = res[0] + '.' + res[1:4]
        res = float(res)
        if len(snum) > 4:
            if int(snum[4]) > 5:
                res += 0.001
        res = round(res, 3)
        return str(res) + ' * 10^{}'.format(len(snum) - 1)


if __name__ == '__main__':
    print("""Индивидуальное задание: x^4 + 9x^3 - 14x^2 - 216x - 320 = 0

Вычислим наибольший по модулю корень:""")
    Y_cur = [0, 0, 0, 1]  # начальные значения y_0, y_1, y_2, y_3
    for i in range(4, 101):
        x = Bernulli(Y_cur)  # считаем следующее значение y_i
        print(i, x[1], x[2])
        Y_cur = x[0]  # новые четыре последних y
    print("\nНаибольший по модулю корень примерно равен {}. Вычислим наименьший.".format(x[2]))
    Y_cur = [0, 0, 0, 1]
    for i in range(4, 101):
        x = Bernulli(Y_cur, False)  # так как теперь считаем наименьший передаём false
        print(i, x[1], x[2])
        Y_cur = x[0]
    print("Наибольший по модулю корень примерно равен {}.".format(x[2] ** (-1)))  # так как x = 1/z надо перевернуть
    print()
    print("""Решим уравнение методом Лобачевского-Греффе. p - степень квадрирования""")
    N = ['z', 'a', 'b', 'c', 'd', 'e', 'f', 'y', 'j', 'h', 'i', 'j', 'k', 'l', 'n', 'm', 'o', 'p']
    # список разных символов, чтобы при выводе не было одинаковых переменных
    print("""x^4 + 9x^3 - 14x^2 - 216x - 320 = 0""")
    a = [1, 9, -14, -216, -320]  # все коэффициенты
    usl = True  # флаг, который будет контролировать условие окончания
    p = 0  # степень квадрирования
    while usl:  # пока условие окончания не достигнуто...
        p += 1  # увеличиваем степень квадрирования, в сл строке квадирируем
        a, prev_a = kvadrirov(a), a  # новые коэффициенты и старые коэффициенты
        print("""{}{}^4 + {}{}^3 + {}{}^2 + {}{} + {} = 0,    p = {}""".format(a[0], N[len(N) % p - 1],
                                                                               to_scientific_notation(a[1]) + ' * ',
                                                                               N[len(N) % p - 1],
                                                                               to_scientific_notation(a[2]) + ' * ',
                                                                               N[len(N) % p - 1],
                                                                               to_scientific_notation(a[3]) + ' * ',
                                                                               N[len(N) % p - 1],
                                                                               to_scientific_notation(a[4]), p))
        # выводим на экран новое квадрированное уравнение
        counter = 0  # счетчик одинаковых значений
        for num in range(5):
            fi = to_scientific_notation(a[num], True)  # переводим старое и новое значения в форму 4.993 * 10^3
            se = to_scientific_notation(prev_a[num], True)
            if str(int(fi * 100))[:7] == str(int((se ** 2) * 100))[:7]:  # сравниванием эти значения
                counter += 1  # если они одинаковы в пределах точности вычислений, то увеличиваем счётчик
        if counter == 5:  # если все пять значений оказались равны
            print('Условие окончания вычислений выполнено. Итоговая степень квадрирования: {}'.format(p))
            usl = False  # опускаем флаг
    Y = []  # массив корней квадрированного кравнения
    X = []  # массив корней изначального уравнения
    for i in range(4):
        y = (-1 * a[i + 1]) / a[i]
        Y.append(y)
        X.append(abs(y) ** (1 / (2 ** p)))  # считаем корни по формуле
    print("""Считаем y. y - корень квадрированного уравнения.
y = -b_n / b_n-1
y_1 = {:.0f}
y_2 = {:.0f}
y_3 = {:.0f}
y_4 = {:.0f}""".format(*Y))
    print("""Из y получаем x. x равен корню 2^p степени от y.
x_1 = {}
x_2 = {}
x_3 = {}
x_4 = {}""".format(*X))  # выводим результат
